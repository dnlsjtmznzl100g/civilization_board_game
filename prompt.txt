<문제는 순서야>
1. ai에게 바로 원하는 걸 말하지 않는다. << 1번에 많은 양을 주면 흔들리니까
2. 참고할 자료를 준다 "요약해주고, 내가 참고할 만한지 평가해줘"
3.평가 기준을 정한다 "이걸 평가할 때 실무에세 바로 사용 가능한지 기준으로 봐줘"
4. 살짝 흘리기 "사실 나는 이런 걸 하려고 해.", "방향이 이래" (구현하라고 재촉하지 않기)
5. 자료 진위 여부 "이 자료가 목적에 맞을까?","그대로 쓸꺼? 개념만 가져올까?","다른 참고자료가 더 좋을까?"
6. 방향 정리 (구현X) 
"내가원하는 건 이거야. 바로 만들지 말고, 어떤 식으로 가는게 좋은지 정리 먼저 해줘. 지금 해야할 일, 나중에 할 일,안해도 될일 나눠줘"
7. 구현 스펙 요구 " 이방향을 기준으로 구현 스펙 정리해줘"
8. 플랜 스펙 요구 "이 스펙을 기준으로 실제 진행 순서를 단계별로 다시 짜줘"

================================================
<ai가 짜준 코딩이 맘에 들지 않는다면? spec kit!>
ai에겐 정확한 지시가 필요해요. << spec kit!

spec kit?: 명세서(상세 설계도)부터 쓰고, 코드로 틀을 채우기
vibe코딩 시대엔 명세서가 거대한 역할을 한다.
"잘못된 일이 있으면, 코드가 아니라 명세서로 돌아간다"

[spec kit 작동 방법 4단계]
각 단계마다 역할이 있다.
다음 단계로 넘어가지 전엔 반드시 검증한다
검증이 완료되기 전까지 다음으로 넘어가지 않는다.

1.  specify
뭘 만들고 싶은지, 왜 만드는지를 다룬다.
사용자 경험, 성공, 누가 사용하는가? 어떤 문제를 해결해줄 것인가?
어떻게 상호작용 하는가? 어떤 결과가 중요한가?

2. plan단계에서 기술적으로 들어간다.
원하는 기술 스택, 아키텍쳐, 제약사항을 ai에게 알려주면 ai가 포괄적 기술 구현 계획을 세운다
ex) 레거시 시스템과 연동, 규제 요구 사항, 성능 목표, 아키텍쳐 패턴 및 표준

3. task단계에서 ai가 명세서와 계획을 받아 실제 작업으로 분해한다.
작고 리뷰 가능한 조각들로 나눈다. 각각이 퍼즐의 특정 부분을 해결한다.
"각 작업은 독립적으로 구현하고 테스트할 수 있어야 한다."

4. 구현 단계에서 ai가 작업들을 하나씩 or 병렬로 처리한다.
핵심은 "특정 문제를 해결하는 집중된 변경사항을 리뷰하는 것" << 그냥 복붙해서 띡하지 말란 소리!
ai는 뭘 만들어야 하는지 알고 << 명세서
어떻게 만들어야 할지도 알고 << 계획
무엇을 해야하는지도 아니까 << 작업

개발자의 역할
방향제시 + 검증
ex) 이 명세서가 내 생각대로, 만들고 싶은 걸 담았는가?
계획이 현실의 제약사항을 고려했나
ai가 놓친 부분, 엣지 케이스가 존재하는가?

직접 해보기
specify를 설치한다.
1. /specify: 무엇과 왜에 집중해 프롬프트 입력 >>  ai가 명세서 출력
2. /plan: 명령을 써서 ai가 기술적 구현 계획을 만들게 한다.
3. /tasks: 명령으로 ai가 명세서오 ㅏ계획을 실행 가능한 작업으로 분해하게 만든다
ai는 이목록을 사용해 프로젝트 요구사항을 구현한다.

왜 통할까?
ai는 독심술사가 아니다. 
처음부터 명확한 명세서를 제공하고, 기술 계획과 집중된 작업들까지 주면,ai는 명확해진다.
뭘 만들지, 어떻게 만들지, 어떤 순서로 해야할지 ai가 알고 작업을 시작한다.
명세서가 의도를 명확히 담아내면
계획이 의도를 기술적 결정으로 변환하고
작업이 기술적 결정을 구현 가능한 조각으로 분해해
ai가 실제 구현을 코딩으로 처리한다.

보안정책, 규제 사항, 규칙, 디자인 시스템 제약, 니즈 등의 요구사항을 spec kit을 사용해 
명세서와 계획에 넣는다.

------------------------------------------
제미나이에게
"OpenSpec 방식으로 civ_game의 **'타일 기반 맵 시스템'**에 대한 첫 번째 명세를 짜보려고 해.
TypeScript와 Firebase(Firestore)를 쓸 거야. 제안서와 명세 초안을 만들어줘."


새로 추가할 [유닛 시스템] 명세가 기존의 명세와 충돌하는 부분이 있을까?" <<< 충돌을 위해 꼭 추가할 것


=====================================================================================================================================
<문서화 4단계 법칙>
새로운 정보 찾았을 때: ~찾았어 정리해서, ~에 추가해.
새 기능 만들 때: 새 기능 만들었어. 해당 기능의 파일 위치, 사용법, 연결된 시스템 등을 features.md에 추가해
기능 업그레이드했을 때: ~개선했어.changelog.md에 뭐 바뀌었는지 써.
에러 났을 때: 이 에러 해결했어. errors.md에 해결법 추가해

매일 작업 끝나고
오늘 한 거 정리해서 문서 업데이트 해

일주일에 1번
문서들 정리해. 중복제거하고 합쳐

새 오픈소스를 찾았다면
~찾았어. opensource.md에 정리해

핵심 명령 4개
처음 시작할 때: 분석해서 문서 만들어
새로운거 만들 때 마다: 이거 문서에 추가해
일주일에 1번: 문서 정리해
문서가 너무 많다면: 중복 제거해
====================================================================
<claude code 제대로 쓰기>

요약
claude가 스스로 배우게 하라
claude는 제작사의 모든 문서를 학습할 수 있다.
anthropic github의 53개 레포지토리를 claude에게 읽히면, 당신의 프로젝트에 맞는 맞춤형 ai개발 환경이 자동 구성된다
설명서를 ai가 읽게 하라.

------------------핵심!!!!-------------------------
anthropic github 저장소의 claude-code관료 자룔를 전부 분석해줘
무엇을 할 수 있고, 어떻게 설정하면 좋을지 정리해.
----------------------------------------------------
학습한 ai에게 설계, 보안 등 설명
실수도 학습에 포함
"이건 수정하면 안돼. 공식문서에서 이런 실수 마근 방법 찾아서 적용해"

==========================================================================
ai 협업 생산성 높이는 6단계 체크 리스트 프롬프트 (다양한 ai를 사용할 때 필수)
(1,2번은 사람이 아래 틀에 맞게 작성해야 합니다!)

0. 작업 명세를 확인해
1. 방금한 작업 명세에 체크하고 기록해 "완료한 것"/"개선된 점"/"미흡한 점"
2. 다음 할 일과 준비물 정리해 "다음 단계" / "필요한 리소스"
3. 필요한 준비물 있는지 확인해 "라이브러리,api,파일" / 없으면 "확보 방법"
4. 우리 프로젝트에 이미 있는거 파악해 "비슷한 기능 구현 여부" / "재사용 가능 코드"
5. 외부 라이브러이 활용 가능 여부 확인해 "쓸 수 있는 기능"/"파일 경로와 사용법"
6. 준비 완료면 시작하고, 아니면 준비부터
7. 작업 명세를 업데이트해.

ex.1)
방금한 작업 명세에 체크하고 기록해
완료한 것: 교역 계산 가능
개선된 점: 플레이어가 버튼만 누르면 교역을 얻을 수 있다.
미흡한 점: 교역 계산 방법이 기획가 다르다

ex.2)
다음 할 일과 준비물 정리해
다음 단계: 교역 계산 방법을 기획한대로 바꿔보자
필요한 리소스: 주변 타일 8칸을 계산해야 해

============================================================================
<바이브 코딩시 주의점>
vivecoding is not an excuse for low-quality work

주로 발생하는 문제
에러 헨들링이 없음
성능 문제
보안 구멍: sql injection
논리적 취약 코드: 예상치 못한 입력에 취약

ai가 만든 초안을 비판적으로 검토하고 개선하고 품질 기준을 충족하는지 확인하라.
1. 코드를 철저히 검토하고 테스트한다.
2. 에러 케이스, 보안, 성능 특성을 고려한다
3. 필요에 따라 리펙터링 or 개선한다
4. 팀의 코딩 표준과 일치하는지 확인한다.
5. ai는 도구다. 사용자는 당신. 책임은? 당신이 진다.

나는 그렇게 뛰어난 개발자는 아닌뎁...
타입 언어가 vivecoding에 있어 유리한다.
왜? typescript는 실행하기 전 문제가 있음을 알린다. >> 컴파일 타임 체크
python은 직접 돌려봐야 알 수 있으니, 에러 잡는 시간 차이가 유의미하게 나는 것
>> ai가 짜준 코드가 알아서 문제를 찾고 고치고~~ 알아서 문젤르 해결해준다.

==================================================

<작가가 직접 게임을 만들어보며 느낀 점>

godot! 가볍고 쉽고 rust지원되고(gdscript(간단구리), gdextension(유지보수,성능,서버연동,멀티플)), 2d엔진이다.
(기능은 유니티 압승이라 한다..)

chat gpt로 설계하고 명세서 만들고 계획 세우고, 연결하고, 구조 세우고
claude code가 실제로 구현
cursor가 정리 (중복 제거, 버그 찾기, 최적화)

====================================================================

<부록: spec기능 사용법>

==================
[python 기반]
uv tool install specify-cli --from git+https://github.com/github/spec-kit.git
uvx --from git+https://github.com/github/spec-kit.git specify init<PROJECT_NAME>]
#신규작성
specify init <PROJECT_NAME>

[typescript 기반]
. OpenSpec
npm install -g @fission-ai/openspec@latest
cd your-project-folder
openspec init

3. 프로젝트 컨텍스트 채우기
초기화 직후, AI 어시스턴트(예: Cursor Chat이나 Claude Code)를 열고 아래와 같이 요청하여
project.md를 자동으로 채우는 것이 좋습니다.

"내 프로젝트를 분석해서 openspec/project.md 파일을 작성해줘. 기술 스택, 코딩 컨벤션, 아키텍처 패턴을 포함해줘."

4. 주요 슬래시 커맨드 (AI 도구 내 사용)
OpenSpec은 설치 후 AI 채팅창에서 슬래시(/) 커맨드로 동작하는 것이 특징입니다. 
(도구에 따라 접두사가 opsx 또는 openspec으로 자동 설정됩니다.)

/opsx:new [작업명]: 새로운 기능 구현이나 수정을 위한 폴더 생성
/opsx:ff (Fast-Forward): 제안서(Proposal), 명세(Spec), 작업 목록(Tasks)을 한 번에 자동 생성
/opsx:apply: 합의된 명세를 바탕으로 실제 코드를 작성
/opsx:archive: 작업 완료 후 명세를 기록으로 보관


github spec kit << 명세서 쓰는 법 배우기
typescript와 rust쓰면 에러가 줄어든다
claude.md로 ai에게 내 취향을 알려줄 수 있다.
==========================================================================
godot vivecoding
고도 웹 에디터
bgm
게임 광고
